# Основы программирования на Java

## Простая программа на Java

```java
public class Sample
{
   public static void main(String[] args)
   {
      System.out.println("Hello!");
      System.out.println("Welcome to Java!");
   }
}
```

Проанализируем исходный код класса `Sample`. При определении класса вначале идет модификатор доступа `public`, который указывает, что данный класс будет доступен всем, то есть его можно будет запустить из командной строки. Далее идет ключевое слово `class`, пока будем это считать неким контейнером, в котором реализована программная логика, определяющая порядок работы приложения. Классы являются стандартными блоками, из которых состоят все приложения, написанные на Java. Все, что имеется в программе на Java, должно находиться в пределах класса. Затем идёт название класса `Sample`.

Файл, содержащий исходный текст, должен называться так же, как и открытый (`public`) класс, и иметь расширение файла `.java`. Таким образом, код рассматриваемого здесь класса следует разместить в файле `Sample.java`.

Входной точкой в программу на языке Java является метод `main`, который определен в классе. Именно с него начинается выполнение программы. Он обязательно должен присутствовать в программе. При этом его заголовок может быть только таким:

```java
public static void main (String args[])
```

_Следует обратить внимание на то, что в языке Java учитывается регистр букв. Так, если вы перепутаете их (например, наберете `Main` вместо `main`), рассматриваемая программа выполняться не будет._

Вначале заголовка метода идет модификатор `public`, который указывает, что метод будет доступен извне (из командной строки и из других классов). Слово `static` указывает, что метод `main` - статический, а слово `void` - что он не возвращает никакого значения. Далее в скобках идут параметры метода - `String args[]` - это массив `args`, который хранит значения типа `String`, то есть строки. При запуске программы через этот массив можно передать в программу различные данные.

Основным строительным блоком методов на языке Java являются инструкции. Каждая инструкция выполняет некоторое действие, например, вызовы других методов, объявление переменных и присвоение им значений. После завершения инструкции в Java ставится точка с запятой (`;`). Данный знак указывает компилятору на конец инструкции.

После заголовка метода идет его блок кода, который содержит набор выполняемых инструкций. Он заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками:

```java
{
    System.out.println("Hello!");
    System.out.println("Welcome to Java!");
}
```

В рассматриваемом примере кода при выполнении метода `main` в консоль выводятся текстовые строки. Для этой цели используется объект `System.out` и вызывается его метод `println`. Метод всегда отделяется от объекта точкой.

## Комментирование кода

Код программы может содержать комментарии. Комментарии позволяют понять смысл программы, что делают те или иные ее части. При компиляции комментарии игнорируются и не оказывают никакого влияния на работу приложения и на его размер.

В Java есть два основных типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша `//`. А многострочный комментарий заключается между символами `/* текст комментария */`. Он может размещаться на нескольких строках. Например:

```java
/*
    Многострочный комментарий

    Объявление нового класса, который содержит код программы
*/
public class Sample { // начало объявления класса Sample

    // определение метода main
    public static void main(String[] args) { // объявление нового метода
        System.out.println("Hello Java!"); // вывод строки на консоль
    } // конец объявления нового метода
} // конец объявления класса Sample
```

## Встроенные типы данных

Язык Java является строго типизированным. Это означает, что тип каждой переменной должен быть явно определен. При этом переменная может принимать только те значения, которые соответствуют ее типу. Если переменная представляет целочисленный тип, то она не может хранить дробные числа.

### Целочисленные типы данных

* `byte`: хранит целое число от `-128` до `127` и занимает 1 байт:

``` java
byte a = 3;
byte b = 8;
```

* `short`: хранит целое число от `-32768` до `32767` и занимает 2 байта:

``` java
short a = 3;
short b = 8;
```

* `int`: хранит целое число от `-2147483648` до `2147483647` (больше 2 млрд) и занимает 4 байта:

``` java
int a = 4;
int b = 9;
```

* `long`: хранит целое число от `–9223372036854775808` до `9223372036854775807` и занимает 8 байт:

``` java
long a = 5L;
long b = 10L;
```

Как правило, наиболее удобным считается тип `int`.

### Числовые типы данных с плавающей точкой

* `float`: хранит число с плавающей точкой от -3.40282347E+38F до 3.40282347E+38F (16-7 значащих десятичных цифр) и занимает 4 байта:

``` java
float x = 8.5F;
float y = 2.7F;
```

* `double`: хранит число с плавающей точкой от -1.7976931348623157E+308F до 1.7976931348623157E+308F (15 значащих десятичных цифр) и занимает 8 байт

``` java
double x = 8.5;
double y = 2.7;
```

В качестве разделителя целой и дробной части в дробных литералах используется точка.

Для большинства приложений тип `double` считается более удобным.

### Символьный тип данных

* `char`: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта, диапазон хранимых значений от 0 до 65535:

``` java
char a = 'A';
char b = 65; // символ 'A'
```

### Логический тип данных

* `boolean`: хранит значение `true` (истина) или `false` (ложь):

``` java
boolean isActive = false;
boolean isAlive = true;
```

## Переменные и константы

Переменные служат в Java для хранения значений. А константы являются переменными, значения которых не изменяются.

### Переменные

Переменная представляет именованную область памяти, которая хранит значение определенного типа. Каждая переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.

Пример объявления переменной:

``` java
int x;
```

В этом выражении объявляется переменная `x` типа `int`. То есть `x` будет хранить некоторое число не больше 4 байт.

Объявив переменную, можно присвоить ей значение:

``` java
int x;  // объявление переменной
x = 10; // присвоение значения
```

Также можно присвоить значение переменной при ее объявлении. Этот процесс называется инициализацией:

``` java
int x = 10;            // объявление и инициализация переменной
System.out.println(x); // 10
```

Если не присвоить переменной значение до ее использования, то можно получить ошибку, например, в следующем случае:

``` java
int x;
System.out.println(x);
```

Отличительной особенностью переменных является то, что мы можем в процессе работы программы изменять их значения:

``` java
int x = 10;
System.out.println(x); // 10
x = 25;
System.out.println(x); // 25
```

### Константы

Кроме переменных, в Java для хранения данных можно использовать константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется также, как и переменная, только вначале идет ключевое слово `final`:

``` java
final double PI = 3.14;
System.out.println(PI); // 3.14
// PI = 3.1415;         // так уже нельзя написать, так как PI - константа
```

Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если есть переменная для хранения числа pi, то можно объявить ее константой, так как ее значение постоянно.

## Операции

### Арифметические операции

* `+` - операция сложения двух чисел:

``` java
int a = 10;
int b = 7;
int c = a + b; // 17
int d = 4 + b; // 11
```

* `-` - операция вычитания двух чисел:

``` java
int a = 10;
int b = 7;
int c = a - b; // 3
int d = 4 - a; // -6
```

* `*` - операция умножения двух чисел

``` java
int a = 10;
int b = 7;
int c = a * b; // 70
int d = b * 5; // 35
```

* `/` - операция деления двух чисел:

``` java
int a = 20;
int b = 5;
int c = a / b;         // 4
double d = 22.5 / 4.5; // 5.0
```

При делении стоит учитывать, что если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной `float` или `double`:

``` java
double k = 10 / 4; // 2
System.out.println(k);
```

Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:

``` java
double k = 10.0 / 4; // 2.5
System.out.println(k);
```

* `%` - получение остатка от деления двух чисел:

``` java
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4 * 5 = 2)
```

### Арифметические операции с присвоением

В языке Java предусмотрена сокращенная запись арифметических операций с присовением.

* `+=`
``` java
c += b;    // переменной "c" присваивается результат сложения "c" и "b"
с = с + b; // равнозначная инструкция
```

* `-=`
``` java
c -= b;    // переменной "c" присваивается результат вычитания "b" из "c"
с = с - b; // равнозначная инструкция
```

* `*=`

``` java
c *= b;    // переменной "c" присваивается результат произведения "c" и "b"
с = с * b; // равнозначная инструкция
```

* `/=`

``` java
c /= b;    // переменной "c" присваивается результат деления "c" на "b"
с = с / b; // равнозначная инструкция
```

* `%=`

``` java
c %= b;    // переменной "c" присваивается остаток от деления "c" на "b"
с = с % b; // равнозначная инструкция
```

### Инкрементация и декрементация

Инкрементация - увеличение значения переменной на единицу.

Декрементация - уменьшение значения переменной на единицу.

Существуют два вида операций инкремента и декремента. Оба этих вида операций изменяют значение переменной на единицу. Их отличие проявляется только тогда, когда эти операции присутствуют в присваивании. В префиксной форме сначала изменяется значение переменной, и только лишь потом присваивается, а в постфиксной форме присваивается прежнее значение этой переменной, и лишь после данной операции оно изменяется на единицу.

_Операции `++` и `--` изменяют значение переменной, поэтому их нельзя применять к самим числам. Например, выражение `4++` считается недопустимым._

* `++` (префиксный инкремент)

Предполагает увеличение переменной на единицу, например, `z = ++y` (вначале значение переменной `y` увеличивается на `1`, а затем ее значение присваивается переменной `z`)

``` java
int a = 8;
int b = ++a;           // Равнозначные инструкции: b = a + 1;
System.out.println(a); // 9
System.out.println(b); // 9
```

* `++` (постфиксный инкремент)

Также представляет увеличение переменной на единицу, например, `z = y++` (вначале значение переменной `y` присваивается переменной `z`, а потом значение переменной `y` увеличивается на `1`)

``` java
int a = 8;
int b = a++;           // Равнозначные инструкции: b = a; a = a + 1;
System.out.println(a); // 9
System.out.println(b); // 8
```

* `--` (префиксный декремент)

Уменьшение переменной на единицу, например, `z = --y` (вначале значение переменной `y` уменьшается на `1`, а потом ее значение присваивается переменной `z`)

``` java
int a = 8;
int b = --a;           // Равнозначные инструкции: b = a - 1;
System.out.println(a); // 7
System.out.println(b); // 7
```

* `--` (постфиксный декремент)

`z = y--` (сначала значение переменной `y` присваивается переменной `z`, а затем значение переменной `y` уменьшается на `1`)

``` java
int a = 8;
int b = a--;           // Равнозначные инструкции: b = a; a = a - 1;
System.out.println(a); // 7
System.out.println(b); // 8
```

### Условные выражения

Условные выражения представляют собой некоторое условие и возвращают значение типа `boolean`, то есть значение `true` (если условие истинно), или значение `false` (если условие ложно).

#### Операции сравнения

В операциях сравнения сравниваются два операнда, и возвращается значение типа `boolean` - `true`, если выражение верно, и `false`, если выражение неверно.

* `==` - сравнивает два операнда на равенство и возвращает `true`, если операнды равны, и `false`, если операнды не равны

``` java
int a = 10;
int b = 4;
boolean c = a == b;  // false
boolean d = a == 10; // true
```

* `!=` - сравнивает два операнда и возвращает `true`, если операнды НЕ равны, и `false`, если операнды равны

``` java
int a = 10;
int b = 4;
boolean c = a != b;  // true
boolean d = a != 10; // false
```

* `<` (меньше чем) - возвращает `true`, если первый операнд меньше второго, иначе возвращает `false`

``` java
int a = 10;
int b = 4;
boolean c = a < b; // false
```

* `>` (больше чем) - возвращает `true`, если первый операнд больше второго, иначе возвращает `false`

``` java
int a = 10;
int b = 4;
boolean c = a > b; // true
```

* `>=` (больше или равно) - возвращает `true`, если первый операнд больше второго или равен второму, иначе возвращает `false`

``` java
boolean c = 10 >= 10; // true
boolean b = 10 >= 4;  // true
boolean d = 10 >= 20; // false
```

* `<=` (меньше или равно) - возвращает `true`, если первый операнд меньше второго или равен второму, иначе возвращает `false`

``` java
boolean c = 10 <= 10; // true
boolean b = 10 <= 4;  // false
boolean d = 10 <= 20; // true
```

#### Логические операции

Также в Java есть логические операции, которые также представляют условие и возвращают `true` или false и обычно объединяют несколько операций сравнения. К логическим операциям относят следующие:

* `|` (или)

`c = a | b;` (`c` равно `true`, если либо `a`, либо `b` (либо и `a`, и `b`) равны `true`, иначе `c` будет равно `false`)

* `&` (и)

`c = a & b;` (`c` равно `true`, если и `a`, и `b` равны `true`, иначе `c` будет равно `false`)

* `!` (отрицание)

`c = !b;` (`c` равно `true`, если `b` равно `false`, иначе `c` будет равно `false`)

* `^` (исключающее или)

`c = a ^ b;` (`c` равно `true`, если либо `a`, либо `b` (но не одновременно) равны `true`, иначе `c` будет равно `false`)

* `||` (или)

`c = a || b;` (`c` равно `true`, если либо `a`, либо `b` (либо и `a`, и `b`) равны `true`, иначе `c` будет равно `false`)

* `&&` (и)

`c = a && b;` (`c` равно `true`, если и `a`, и `b` равны `true`, иначе `c` будет равно `false`)

Здесь две пары операций `|` и `||` (а также `&` и `&&`) выполняют похожие действия, однако же они не равнозначны.

Выражение `c = a | b;` будет вычислять сначала оба значения - `a` и `b` и на их основе выводить результат.

В выражении же `c = a || b;` вначале будет вычисляться значение `a`, и если оно равно `true`, то вычисление значения `b` уже смысла не имеет, так как у нас в любом случае уже `c` будет равно `true`. Значение `b` будет вычисляться только в том случае, если `a` равно `false`.

То же самое касается пары операций `&`/`&&`. В выражении `c = a & b;` будут вычисляться оба значения - `a` и `b`.

В выражении же `c = a && b;` сначала будет вычисляться значение `a`, и если оно равно `false`, то вычисление значения `b` уже не имеет смысла, так как значение `c` в любом случае равно `false`. Значение `b` будет вычисляться только в том случае, если `a` равно `true`.

Таким образом, операции `||` и `&&` более удобны в вычислениях, позволяя сократить время на вычисление значения выражения.

#### Таблицы истинности

* Отрицание:

| `a`     | `!a`    |
|---------|---------|
| `false` | `true`  |
| `true`  | `false` |

* И:

| `a`     | `b`     | `a & b` |
|---------|---------|---------|
| `false` | `false` | `false` |
| `false` | `true`  | `false` |
| `true`  | `false` | `false` |
| `true`  | `true`  | `true`  |

* Или:

| `a`     | `b`     | `a || b` |
|---------|---------|----------|
| `false` | `false` | `false`  |
| `false` | `true`  | `true`   |
| `true`  | `false` | `true`   |
| `true`  | `true`  | `true`   |

* Исключающее или:

| `a`     | `b`     | `a ^ b` |
|---------|---------|---------|
| `false` | `false` | `false` |
| `false` | `true`  | `true`  |
| `true`  | `false` | `true`  |
| `true`  | `true`  | `false` |

---

#### Дополнительные материалы

- [Таблица истинности - Википедия](https://ru.wikipedia.org/wiki/Таблица_истинности)

### Преобразование числовых типов

Каждый базовый тип данных занимает определенное количество байт памяти. Это накладывает ограничение на операции, в которые вовлечены различные типы данных.

``` java
int a = 4;
byte b = a; // Ошибка
```

В данном коде произойдёт ошибка. Хотя и тип `byte`, и тип `int` представляют целые числа. Более того, значение переменной `a`, которое присваивается переменной типа `byte`, вполне укладывается в диапазон значений для типа `byte` (от `-128` до `127`). Тем не менее происходит ошибка на этапе компиляции. Поскольку в данном случае присваиваются некоторые данные, которые занимают 4 байта, переменной, которая занимает всего один байт.

Тем не менее в программе может потребоваться, чтобы подобное преобразование было выполнено. В этом случае необходимо использовать операцию преобразования типов (операция `()`):

``` java
int a = 4;
byte b = (byte) a;     // преобразование типов: от типа int к типу byte
System.out.println(b); // 4
```

Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение. Например, в случае операции `(byte) a`, идет преобразование данных типа `int` в тип `byte`. В итоге мы получим значение типа `byte`.

#### Автоматическое преобразование

![](img/автоматическое_преобразование_числовых_типов.png)

Стрелками на рисунке показано, какие преобразования типов могут выполняться автоматически. Пунктирными стрелками показаны автоматические преобразования с потерей точности.

Пример автоматического преобразования:

``` java
byte b = 7;
int d = b; // преобразование от byte к int
```

В данном случае значение типа `byte`, которое занимает в памяти 1 байт, расширяется до типа `int`, которое занимает 4 байта.

Автоматические преобразования представлены следующими цепочками:

`byte` -> `short` -> `int` -> `long`

`int` -> `double`

`short` -> `float` -> `double`

`char` -> `int`

Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований: `int` -> `float`, `long` -> `float` и `long` -> `double`. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.

Пример:

``` java
int a = 2147483647;
float b = a;           // от типа int к типу float
System.out.println(b); // 2.14748365E9
```

#### Приведение типов

Во всех остальных преобразованиях примитивных типов явным образом применяется операция привидения типов. Обычно это преобразования от типа с большей разрядностью к типу с меньшей разрядностью:

``` java
long a = 4;
int b = (int) a;
```

При применении привидения типов мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:

```
int a = 5;
byte b = (byte) a;
System.out.println(b); // 5
```

Число `5` укладывается в диапазон значений типа `byte`, поэтому после привидения переменная `b` будет равна `5`.

Но в следующем примере результатом будет число `2`:

``` java
int a = 258;
byte b = (byte) a;
System.out.println(b); // 2
```

В данном случае число `258` вне диапазона для типа `byte` (от `-128` до `127`), поэтому произойдет усечение значения.

_Почему результатом будет именно число `2`? Число `a`, которое равно `258`, в двоичном системе будет равно `00000000 00000000 00000001 00000010`. Значения типа `byte` занимают в памяти только 8 бит. Поэтому двоичное представление числа `int` усекается до 8 правых разрядов, то есть `00000010`, что в десятичной системе дает число `2`._

При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:

``` java
double a = 56.9898;
int b = (int) a;
```

Здесь значение числа `b` будет равно `56`, несмотря на то, что число `57` было бы ближе к `56.9898`.

#### Преобразования при операциях

Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:

* если один из операндов операции относится к типу `double`, то и второй операнд преобразуется к типу `double`
* если предыдущее условие не соблюдено, а один из операндов операции относится к типу `float`, то и второй операнд преобразуется к типу `float`
* если предыдущие условия не соблюдены, один из операндов операции относится к типу `long`, то и второй операнд преобразуется к типу `long`
* иначе все операнды операции преобразуются к типу `int`

Примеры преобразований:

``` java
int a = 3;
double b = 4.6;
double c = a + b;
```

Так как в операции участвует значение типа `double`, то и другое значение приводится к типу `double` и сумма двух значений `a + b` будет представлять тип `double`.

Другой пример:

``` java
byte a = 3;
short b = 4;
byte c = (byte) (a + b);
```

Две переменных типа `byte` и `short` (не `double`, `float` или `long`), поэтому при сложении они преобразуются к типу `int`, и их сумма `a + b` представляет значение типа `int`. Поэтому если затем мы присваиваем эту сумму переменной типа `byte`, то нам опять надо сделать преобразование типов к `byte`.

Если в операциях участвуют данные типа char, то они преобразуются в int:

``` java
int d = 'a' + 5;
System.out.println(d); // 102
```

## Символьные строки

В языке Java отсутствует встроенный тип для символьных строк. Вместо этого в стандартной библиотеке Java содержится класс `String`. Каждая символьная строка, заключенная в кавычки, представляет собой экземпляр класса `String`:

``` java
String е = ""; // пустая строка
String greeting = "Hello";
```

По существу, символьная строка Java представляет собой последовательность символов (тип данных `char`).

### Подстроки

С помощью метода `substring()` из класса `String` можно выделить подстроку из отдельной символьной строки. Например, в результате выполнения приведенного ниже фрагмента кода формируется подстрока `"Неl"`.

``` java
String greetiпg = "Hello";
String s = greeting.substring(0, 3);
```

Второй параметр метода `substring()` обозначает позицию символа, который не следует включать в состав подстроки. В данном примере требуется скопировать символы на трех позициях, 0, 1 и 2 (т.е. от позиции 0 до позиции 2 включительно), поэтому при вызове метода `substring()` указываются значения 0 и 3, обозначающие копируемые символы от позиции 0 и до позиции 2 включительно, но исключая позицию 3.

### Сцепление строк

В языке Java, как и в большинстве других языков программирования, предоставляется возможность объединить две символьные строки, используя знак `+` операции сцепления.

``` java
String expletive = "Expletive";
String PG13 = "deleted";
String message = expletive + PG13;
```

В приведенном выше фрагменте кода переменной `message` присваивается символьная строка `"Expletivedeleted"`, сцепленная из двух исходных строк. (Обратите внимание на отсутствие пробела между словами в этой строке. Знак `+` операции сцепления соединяет две строки точно в том порядке, в каком они были заданы в качестве операндов.)

При сцеплении символьной строки со значением, не являющимся строковым, это значение преобразуется в строковое. В приведенном ниже примере кода переменной `rating` присваивается символьная строка `"PGlЗ"`, полученная путем сцепления символьной строки с числовым значением, автоматически преобразуемым в строковое.

``` java
int age = 13;
String rating = "PG" + age;
```

Если требуется соединить вместе две символьные строки, разделяемые каким-нибудь знаком, то для этой цели можно воспользоваться статическим методом `join()`, как показано ниже.

``` java
String all = String.join(" / ", "S", "М", "L", "XL"); // в итоге переменная all содержит строку "S / М / L / XL"
```

В версии 11 появился метод `repeat()`, позволяющий повторять сколько требуется заданную символьную строку:

``` java
String repeated = "Java".repeat(3); // повторить строку "Java", чтобы
                                    // получить в итоге строку "JavaJavaJava"
```

### Принцип постоянства символьных строк

В классе `String` отсутствуют методы, которые позволяли бы изменять символы в существующей строке. Так, если требуется заменить символьную строку в переменной `greeting` с `"Hello"` на `"Help!"`, этого нельзя добиться одной лишь заменой двух последних символов. В языке Java можно внести необходимые изменения в строку, выполнив сцепление подстроки, которую требуется сохранить, с заменяющими символами, как показано ниже. В итоге переменной `greeting` присваивается символьная строка `"Help!"`.

``` java
greeting = greeting.substring(O, 3) + "р!";
```

### Проверка символьных строк на равенство

Чтобы проверить две символьные строки на равенство, достаточно вызвать метод `equals()`. Так, выражение `s.equals(t)` возвращает логическое значение `true`, если символьные строки `s` и `t` равны, а иначе - логическое значение `false`. Следует, однако, иметь в виду, что в качестве `s` и `t` могут быть использованы строковые переменные или константы. Например, следующее выражение вполне допустимо:

``` java
"Hello!".equals(greeting);
```

А для того, чтобы проверить идентичность строк, игнорируя отличия в прописных и строчных буквах, следует вызвать метод `equalsIgnoreCase()`, как показано ниже.

``` java
"Hello".equalsIgnoreCase("hello");
```

Для проверки символьных строк на равенство нельзя применять операцию `==`. Она лишь определяет, хранятся ли обе строки в одной и той же области памяти. Разумеется, если обе строки хранятся в одном и том же месте, они должны совпадать. Но вполне возможна ситуация, когда одинаковые символьные строки хранятся в разных местах. Ниже приведен соответствующий пример.

``` java
String greeting = "Hello"; // инициализировать переменную greeting
                           // символьной строкой "Hello"
if (greeting == "Hello") ...
    // возможно, это условие истинно
if (greeting.substring(O, 3) == "Hel")
    // возможно, это условие ложно
```

### Построение символьных строк

Время от времени у вас будет возникать потребность в составлении одних символьных строк из других, более коротких строк, вводимых с клавиатуры или из файла. Было бы неэффективно постоянно пользоваться для этой цели сцеплением строк. Ведь при каждом сцеплении символьных строк конструируется новый объект типа `String`, на что расходуется время и память. Этого можно избежать, применяя класс `StringBuilder`.

Если требуется создать символьную строку из нескольких небольших фрагментов, сконструируйте сначала пустой объект в качестве построителя символьной строки:

``` java
StringBuilder builder = new StringBuilder();
```

Когда же потребуется добавить новый фрагмент в символьную строку, вызовите метод `append()`, как показано ниже.

``` java
builder.append(ch);  // добавить единственный символ
builder.append(str); // добавить символьную строку
```

Завершив составление символьной строки, вызовите метод `toString()`. Таким образом, вы получите объект типа `String`, состоящий из последовательности символов, содержащихся в объекте построителя символьных строк:

``` java
String completedString = builder.toString();
```

## Консольный ввод/вывод

Наиболее простой способ взаимодействия с пользователем представляет консоль: мы можем выводить на консоль некоторую информацию или, наоборот, считывать с консоли некоторые данные. Для взаимодействия с консолью в Java применяется класс `System`, а его функциональность собственно обеспечивает консольный ввод и вывод.

### Вывод в консоль

Для создания потока вывода в класс `System` определен объект `out`. В этом объекте определен метод `println`, который позволяет вывести на консоль некоторое значение с последующим переводом курсора консоли на следующую строку. Например:

``` java
public class Program {
    public static void main(String[] args) {
        System.out.println("Hello world!");
        System.out.println("Bye world...");
    }
}
```

В метод `println` передается любое значение, как правило, строка, которое надо вывести на консоль. И в данном случае мы получим следующий вывод:

``` text
Hello world!
Bye world...
```

При необходимости можно и не переводить курсор на следующую строку. В этом случае можно использовать метод `System.out.print()`, который аналогичен `println` за тем исключением, что не осуществляет перевода на следующую строку.

``` java
public class Program {
    public static void main(String[] args) {
        System.out.print("Hello world!");
        System.out.print("Bye world...");
    }
}
```

Консольный вывод данной программы:

``` text
Hello world!Bye world...
```

Но с помощью метода `System.out.print` также можно осуществить перевод каретки на следующую строку. Для этого надо использовать escape-последовательность `\n`:

``` java
System.out.print("Hello world \n");
```

Нередко необходимо подставлять в строку какие-нибудь данные. Например, у нас есть два числа, и мы хотим вывести их значения на экран. В этом случае мы можем, например, написать так:

``` java
public class Program {
    public static void main(String[] args) {
        int x=5;
        int y=6;
        System.out.println("x=" + x + "; y=" + y);
    }
}
```

Консольный вывод программы:

``` text
x=5; y=6
```

Но в Java есть также функция для форматированного вывода: `System.out.printf()`. С ее помощью можно переписать предыдущий пример следующим образом:

``` java
int x=5;
int y=6;
System.out.printf("x=%d; y=%d \n", x, y);
```

В данном случае символы `%d` обозначают спецификатор, вместо которого подставляет один из аргументов. Спецификаторов и соответствующих им аргументов может быть множество. В данном случае у нас только два аргумента, поэтому вместо первого `%d` подставляет значение переменной `x`, а вместо второго - значение переменной `y`. Сама буква `d` означает, что данный спецификатор будет использоваться для вывода целочисленных значений.

Кроме спецификатора `%d` мы можем использовать еще ряд спецификаторов для других типов данных:

- `%x`: для вывода шестнадцатеричных чисел
- `%f`: для вывода чисел с плавающей точкой
- `%e`: для вывода чисел в экспоненциальной форме, например, `1.3e+01`
- `%c`: для вывода одиночного символа
- `%s`: для вывода строковых значений

Например:

``` java
public class Program {
    public static void main(String[] args) {
        String name = "Tom";
        int age = 30;
        float height = 1.7f;
          
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
    }
}
```

При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на `%.2f`, где `.2` указывает, что после запятой будет два знака. В итоге мы получим следующий вывод:

``` text
Name: Tom  Age: 30  Height: 1,70
```

### Ввод с консоли

Для получения ввода с консоли в классе `System` определен объект `in`. Однако непосредственно через объект `System.in` не очень удобно работать, поэтому, как правило, используют класс `Scanner`, который, в свою очередь использует `System.in`. Например, напишем маленькую программу, которая осуществляет ввод чисел:

``` java
import java.util.Scanner;

public class Program {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Input a number: ");
        int num = in.nextInt();
          
        System.out.printf("Your number: %d \n", num);
        in.close();
    }
}
```

Так как класс `Scanner` находится в пакете `java.util`, то мы вначале его импортируем с помощью инструкции `import java.util.Scanner`.

Для создания самого объекта `Scanner` в его конструктор передается объект `System.in`. После этого мы можем получать вводимые значения. Например, в данном случае вначале выводим приглашение к вводу и затем получаем вводимое число в переменную `num`.

Чтобы получить введенное число, используется метод `in.nextInt()`, который возвращает введенное с клавиатуры целочисленное значение.

Пример работы программы:

``` text
Input a number: 5
Your number: 5
```

Класс `Scanner` имеет еще ряд методов, которые позволяют получить введенные пользователем значения:

- `next()`: считывает введенную строку до первого пробела
- `nextLine()`: считывает всю введенную строку
- `nextInt()`: считывает введенное число `int`
- `nextDouble()`: считывает введенное число `double`
- `nextBoolean()`: считывает значение `boolean`
- `nextByte()`: считывает введенное число `byte`
- `nextFloat()`: считывает введенное число `float`
- `nextShort()`: считывает введенное число `short`

То есть для ввода значений каждого примитивного типа в классе `Scanner` определен свой метод.

Например, создадим программу для ввода информации о человеке:

``` java
import java.util.Scanner;

public class Program {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Input name: ");
        String name = in.nextLine();
        System.out.print("Input age: ");
        int age = in.nextInt();
        System.out.print("Input height: ");
        float height = in.nextFloat();
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
        in.close();
    }
}
```

Здесь последовательно вводятся данные типов `String`, `int`, `float` и потом все введенные данные вместе выводятся на консоль. Пример работы программы:

``` text
Input name: Tom
Input age: 34
Input height: 1,7
Name: Tom  Age: 34  Height: 1,70
```

Обратите внимание, что для ввода значения типа `float` (то же самое относится к типу `double`) применяется число "1,7", где разделителем является запятая, а не "1.7", где разделителем является точка. В данном случае все зависит от текущей языковой локализации системы. В данном случае русскоязычная локализация, соответственно вводить необходимо числа, где разделителем является запятая. То же самое касается многих других локализаций, например, немецкой, французской и т.д., где применяется запятая.

## Файловый ввод/вывод

Чтобы прочитать данные из файла, достаточно сконструировать объект типа `Scanner`:

``` java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
```

Если имя файла содержит знаки обратной косой черты, их следует экранировать дополнительными знаками обратной косой черты, как, например, `"с:\\mydirectory\\myfile.txt"`. После этого можно произвести чтение из файла, используя любые упомянутые выше методы из класса `Scanner`.

А для того, чтобы записать данные в файл, достаточно сконструировать объект типа `PrintWriter`, указав в ero конструкторе имя файла:

``` java
PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8);
```

Если файл не существует, он создается. Для вывода в файл можно воспользоваться методами `print()`, `println()` и `printf()` точно так же, как это делается для вывода в консоль (или в стандартный поток вывода `System.out`).

Если вы конструируете объект типа `Scanner` с файлом, который еще не существует, или объект типа `PrintWriter` с именем файла, который не может быть создан, возникает исключение. Компилятор Java рассматривает подобные исключения как более серьезные, чем, например, исключение при делении на нуль. Позже будут рассмотрены различные способы обработки исключений. А до тех пор достаточно уведомить компилятор о том, что при файловом вводе и выводе может возникнуть исключение типа "файл не найден". Для этого в объявление метода `main()` вводится предложение `throws`, как показано ниже.

``` java
public static void main(String[] args) throws IOException {
    Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
    ...
}
```

## Управляющая логика

### Область видимости блоков

Блок состоит из ряда операторов Java, заключенных в фигурные скобки. Блоки определяют область видимости переменных и могут быть вложенными один в другой. Ниже приведен пример одного блока, вложенного в другой блок в методе `main()`.

``` java
public static void main(String[] args) {
    int n;
    {
        int k;
    } // переменная k определена только в этом блоке
}
```

В языке Java нельзя объявлять переменные с одинаковым именем в двух вложенных блоках. Например, приведенный ниже фрагмент кода содержит ошибку и не будет скомпилирован.

``` java
public static void maiп(String(] args) {
    int n;
    {
        int k;
        int n; // ОШИБКА: переопределить переменную n
               // во внутреннем блоке нельзя
    }
}
```

### Условные операторы

Данные операторы позволяют направить работу программы по одному из путей в зависимости от определенных условий.

#### if/else

Выражение `if`/`else` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:

``` java
int num1 = 6;
int num2 = 4;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
}
```

После ключевого слова `if` ставится условие. И если это условие выполняется, то срабатывает код, который помещен далее в блоке `if` после фигурных скобок.

Так как, в данном случае первое число больше второго, то выражение `num1 > num2` истинно и возвращает значение `true`. Следовательно, управление переходит в блок кода после фигурных скобок и начинает выполнять содержащиеся там инструкции, а конкретно метод `System.out.println("Первое число больше второго");`. Если бы первое число оказалось бы меньше второго или равно ему, то инструкции в блоке `if` не выполнялись бы.

Если необходимо, чтобы при несоблюдении условия также выполнялись какие-либо действия, можно добавить блок `else`:

``` java
int num1 = 6;
int num2 = 4;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
} else {
    System.out.println("Первое число меньше второго");
}
```

Но при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. С помощью выражения `else if`, можно обрабатывать дополнительные условия:

```
int num1 = 6;
int num2 = 8;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
} else if (num1 < num2) {
    System.out.println("Первое число меньше второго");
} else {
    System.out.println("Числа равны");
}
```

Также можно соединить сразу несколько условий, используя логические операторы:

``` java
int num1 = 8;
int num2 = 6;
if (num1 > num2 && num1 > 7) {
    System.out.println("Первое число больше второго и больше 7");
}
```

Здесь блок `if` будет выполняться, если `num1 > num2` равно `true` и одновременно `num1 > 7` равно `true`.

#### switch

Конструкция `switch`/`case` аналогична конструкции `if`/`else`, так как позволяет обработать сразу несколько условий:

``` java
int num = 8;
switch (num) {
    case 1: 
        System.out.println("число равно 1");
        break;
    case 8: 
        System.out.println("число равно 8");
        num++;
        break;
    case 9: 
        System.out.println("число равно 9");
        break;
    default:
        System.out.println("число не равно 1, 8, 9");
}
```

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после операторов `сase`. И если совпадение найдено, выполняется соответствующий блок `сase`.

В конце блока `сase` ставится оператор `break`, чтобы избежать выполнения других блоков. Например, если убрать оператор `break` в следующем случае:

``` java
case 8:
    System.out.println("число равно 8");
    num++;
case 9:
    System.out.println("число равно 9");
    break;
```

то выполнился бы блок `case 8`, (поскольку переменная `num` равна `8`). Но так как в этом блоке оператор `break` отсутствует, то начал бы выполняться блок `case 9`.

Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`, как в примере выше. Хотя блок `default` необязателен.

Также мы можем определить одно действие сразу для нескольких блоков `case` подряд:

``` java
int num = 3;
int output = 0;
switch (num) {
    case 1: 
        output = 3;
        break;
    case 2: 
    case 3: 
    case 4: 
        output = 6;
        break;
    case 5: 
        output = 12;
        break;
    default:
        output = 24;
}
System.out.println(output);
```

#### Тернарный оператор

Тернарный оператор имеет следующий синтаксис: `[первый операнд - условие] ? [второй операнд] : [третий операнд]`. Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно `true`, то возвращается второй операнд; если условие равно `false`, то третий. Например:

``` java
int x=3;
int y=2;
int z = x < y ? (x + y) : (x - y);
System.out.println(z);
```

Здесь результатом тернарной операции является переменная `z`. Сначала проверяется условие `x < y`. И если оно соблюдается, то `z` будет равно второму операнду `(x+y)`, иначе `z` будет равно третьему операнду.

### Циклы

Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке Java есть следующие виды циклов:

* `for`
* `do`...`while`
* `while`

#### for

Цикл `for` имеет следующее формальное определение:

``` java
for ([инициализация счетчика]; [условие]; [изменение счетчика]) {
    // действия
}
```

Рассмотрим стандартный цикл for:

``` java
for (int i = 1; i < 9; i++) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}
```

Первая часть объявления цикла - `int i = 1` создает и инициализирует счетчик `i`. Счетчик необязательно должен представлять тип `int`. Это может быть и любой другой числовой тип, например, `float`. Перед выполнением цикла значение счетчика будет равно `1`. В данном случае это то же самое, что и объявление переменной.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока `i` не достигнет `9`.

И третья часть - изменение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: `i--`.

В итоге блок цикла сработает 8 раз, пока значение `i` не станет равным `9`. И каждый раз это значение будет увеличиваться на `1`.

Необязательно указывать все условия при объявлении цикла. Например, можно написать так:

``` java
int i = 1;
for (;;) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}
```

Определение цикла осталось тем же, только теперь блоки в определении у нас пустые: `for (;;)`. Теперь нет инициализированной переменной-счетчика, нет условия, поэтому цикл будет бесконечным.

Либо можно опустить ряд блоков:

``` java
int i = 1;
for (; i<9;) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    i++;
}
```

Этот пример эквивалентен первому примеру: у нас также есть счетчик, только создан он вне цикла. У нас есть условие выполнения цикла. И есть изменение счетчика уже в самом блоке `for`.

Цикл `for` может определять сразу несколько переменных и управлять ими:

``` java
int n = 10;
for (int i = 0, j = n - 1; i < j; i++, j--) {
    System.out.println(i * j);
}
```

#### do...while

Цикл `do` сначала выполняет код цикла, а потом проверяет условие в инструкции `while`. И пока это условие истинно, цикл повторяется. Например:

``` java
int j = 7;
do {
    System.out.println(j);
    j--;
} while (j > 0);
```

В данном случае код цикла сработает 7 раз, пока `j` не окажется равным нулю. Важно отметить, что цикл `do` гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции `while` не будет истинно. Можно написать:

``` java
int j = -1;
do {
    System.out.println(j);
    j--;
} while (j > 0);
```

Хотя переменная `j` изначально меньше `0`, цикл все равно один раз выполнится.

#### while

Цикл `while` сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:

``` java
int j = 6;
while (j > 0) {
    System.out.println(j);
    j--;
}
```

#### Операторы прерывания логики управления программой (break и continue)

Оператор `break` позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу:

Например:

``` java
for (int i = 0; i < 10; i++) {
    if (i == 5)
        break;
    System.out.println(i);
}
```

Когда счетчик станет равным `5`, сработает оператор `break`, и цикл завершится.

Теперь сделаем так, чтобы если число равно `5`, цикл не завершался, а просто переходил к следующей итерации. Для этого используем оператор `continue`:

``` java
for (int i = 0; i < 10; i++) {
    if (i == 5)
        continue;
    System.out.println(i);
}
```

В этом случае, когда выполнение цикла дойдет до числа `5`, программа просто пропустит это число и перейдет к следующему.

## Массивы

Массив представляет набор однотипных значений. Объявление массива похоже на объявление обычной переменной, которая хранит одиночное значение, причем есть два способа объявления массива:

``` java
тип_данных название_массива[];
// либо
тип_данных[] название_массива;
```

Например, определим массив чисел:

``` java
int nums[];
int[] nums2;
```

После объявления массива мы можем инициализовать его:

``` java
int nums[];
nums = new int[4]; // массив из 4 чисел
```

Создание массива производится с помощью следующей конструкции: `new тип_данных[количество_элементов]`, где `new` - ключевое слово, выделяющее память для указанного в скобках количества элементов. Например, `nums = new int[4];` - в этом выражении создается массив из четырех элементов `int`, и каждый элемент будет иметь значение по умолчанию - число 0.

Также можно сразу при объявлении массива инициализировать его:

``` java
int nums[] = new int[4];  // массив из 4 чисел
int[] nums2 = new int[5]; // массив из 5 чисел
```

При подобной инициализации все элементы массива имеют значение по умолчанию. Для числовых типов (в том числе для типа `char`) это число 0, для типа `boolean` это значение `false`, а для остальных объектов это значение `null`. Например, для типа `int` значением по умолчанию является число 0, поэтому выше определенный массив `nums` будет состоять из четырех нулей.

Однако также можно задать конкретные значения для элементов массива при его создании:

``` java
// эти два способа равноценны
int[] nums = new int[] { 1, 2, 3, 5 };

int[] nums2 = { 1, 2, 3, 5 };
```

Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива, так как он вычисляется по количеству элементов в фигурных скобках.

После создания массива мы можем обратиться к любому его элементу по индексу, который передается в квадратных скобках после названия переменной массива:

``` java
int[] nums = new int[4];
// устанавливаем значения элементов массива
nums[0] = 1;
nums[1] = 2;
nums[2] = 4;
nums[3] = 100;

// получаем значение третьего элемента массива
System.out.println(nums[2]); // 4
```

Индексация элементов массива начинается с 0, поэтому в данном случае, чтобы обратиться к четвертому элементу в массиве, нам надо использовать выражение `nums[3]`.

И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу: `nums[5] = 5;`. Если мы так попытаемся сделать, то мы получим ошибку.

### Длина массива

Важнейшее свойство, которым обладают массивы, является свойство length, возвращающее длину массива, то есть количество его элементов:

``` java
int[] nums = {1, 2, 3, 4, 5};
int length = nums.length; // 5
```

Нередко бывает неизвестным последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:

``` java
int last = nums[nums.length-1];
```

### Многомерные массивы

Ранее мы рассматривали одномерные массивы, которые можно представить как цепочку или строку однотипных значений. Но кроме одномерных массивов также бывают и многомерные. Наиболее известный многомерный массив - таблица, представляющая двухмерный массив:

``` java
int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };

int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
```

Визуально оба массива можно представить следующим образом:

**Одномерный массив nums1**

| 0 | 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|---|

**Двухмерный массив nums2**

| 0 | 1 | 2 |
|---|---|---|
| 3 | 4 | 5 |

Поскольку массив `nums2` двухмерный, он представляет собой простую таблицу. Его также можно было создать следующим образом: `int[][] nums2 = new int[2][3];`. Количество квадратных скобок указывает на размерность массива. А числа в скобках - на количество строк и столбцов. И также, используя индексы, мы можем использовать элементы массива в программе:

``` java
// установим элемент первого столбца второй строки
nums2[1][0] = 44;
System.out.println(nums2[1][0]);
```

Объявление трехмерного массива могло бы выглядеть так:

``` java
int[][][] nums3 = new int[2][3][4];
```

### Зубчатый массив

Многомерные массивы могут быть также представлены как "зубчатые массивы". В вышеприведенном примере двухмерный массив имел 2 строчки и три столбца, поэтому у нас получалась ровная таблица. Но мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:

``` java
int[][] nums = new int[3][];
nums[0] = new int[2];
nums[1] = new int[3];
nums[2] = new int[5];
```

### Цикл for each

Цикл "for each" - это специальная версия цикла `for` предназначена для перебора элементов в наборах элементов, например, в массивах и коллекциях. Формальное его объявление:

``` java
for (тип_данных название_переменной : контейнер) {
    // действия
}
```

Например:

``` java
int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i : array) {
    System.out.println(i);
}
```

В качестве контейнера в данном случае выступает массив данных типа `int`. Затем объявляется переменная с типом `int`.

То же самое можно было бы сделать и с помощью обычной версии for:

``` java
int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}
```

В то же время эта версия цикла `for` более гибкая по сравнению с `for (int i : array)`. В частности, в этой версии мы можем изменять элементы:

``` java
int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i < array.length; i++) {
    array[i] = array[i] * 2;
    System.out.println(array[i]);
}
```

### Перебор многомерных массивов в цикле

``` java
int[][] nums = new int[][]
{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
for (int i = 0; i < nums.length; i++) {
    for(int j = 0; j < nums[i].length; j++) {
        System.out.printf("%d ", nums[i][j]);
    }
    System.out.println();
}
```

Сначала создается цикл для перебора по строкам, а затем внутри первого цикла создается внутренний цикл для перебора по столбцам конкретной строки. Подобным образом можно перебрать и трехмерные массивы и наборы с большим количеством размерностей.

## Методы

Если переменные и константы хранят некоторые значения, то методы содержат собой набор операторов, которые выполняют определенные действия.

Общее определение методов выглядит следующим образом:

```
[модификаторы] тип_возвращаемого_значения название_метода([параметры]) {
    // тело метода
}
```

Модификаторы и параметры необязательны.

По умолчанию главный класс любой программы на Java содержит метод `main`, который служит точкой входа в программу:

``` java
public static void main(String[] args) {
  System.out.println("привет мир!");
}
```

Ключевые слова `public` и `static` являются модификаторами. Далее идет тип возвращаемого значения. Ключевое слово `void` указывает на то, что метод ничего не возвращает.

Затем идут название метода - `main` и в скобках параметры метода - `String[] args`. И в фигурные скобки заключено тело метода - все действия, которые он выполняет.

Создадим еще несколько методов:

``` java
public class Program {
    public static void main(String args[]) {
        // ...
    }
    
    void hello() {     
        System.out.println("Hello");
    }
    
    void welcome() {
        System.out.println("Welcome to Java 10");
    }
}
```

Здесь определены два дополнительных метода: `hello` и `welcome`, каждый из которых выводит некоторую строку на консоль. Методы определяются внутри класса - в данном случае внутри класса `Program`, в котором определен метод `main`.

Но если мы скомпилируем и запустим данную программу, то мы ничего не увидим на консоли. В примере выше мы определили два метода, но мы их нигде не вызываем. По умолчанию в программе Java выполняется только метод `main` и все его содержимое. Поэтому, если мы хотим, чтобы другие методы тоже выполнялись, их надо вызвать в методе `main`.

Вызов метода осуществляется в форме:

```
имя_метода(аргументы);
```

После имени метода указываются скобки, в которых перечисляются аргументы - значения для параметров метода.

Например, определим и выполним несколько методов:

``` java
public class Program {
    public static void main(String args[]) {
         hello();
         welcome();
         welcome();
    }
    
    static void hello() {     
        System.out.println("Hello");
    }
    
    static void welcome() {     
        System.out.println("Welcome to Java 10");
    }
}
```

В методе `main` вызывается один раз метод `hello` и два раза метод `welcome`. В этом и заключается одно из преимуществ методов: мы можем вынести некоторые общие действия в отдельный метод и затем вызывать многократно их в различных местах программы. Поскольку оба метода не имеют никаких параметров, то после их названия при вызове ставятся пустые скобки.

Также следует отметить, что чтобы вызвать в методе `main` другие методы, которые определены в одном классе с методом `main`, они должны иметь модификатор `static`.

В итоге после компиляции и выполнения программы мы увидим на консоли:

```
Hello
Welcome to Java 10
Welcome to Java 10
```

### Параметры методов

С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:

``` java
static void sum(int x, int y) {
    int z = x + y;
    System.out.println(z);
}
```

Данная функция принимает два параметра - два числа, складывает их и выводит их сумму в консоль.

А при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:

``` java
public class Program {
    public static void main(String args[]) {      
        int a = 6;
        int b = 8;
        sum(a, b);  // 14
        sum(3, a);  // 9
        sum(5, 23); // 28
    }
    
    static void sum(int x, int y) {
        int z = x + y;
        System.out.println(z);
    }
}
```

Поскольку метод `sum` принимает два значения типа `int`, то на место параметров надо передать два значения типа `int`. Это могут быть и числовые литералы, и переменные типов данных, которые представляют тип `int` или могут быть автоматически преобразованы в тип `int`. Значения, которые передаются на место параметров, еще называются аргументами. Значения передаются параметрам по позиции, то есть первый аргумент первому параметру, второй аргумент - второму параметру и так далее.

Рассмотрим другой пример:

``` java
public class Program {
    public static void main (String args[]) {
        display("Tom", 34);
        display("Bob", 28);
        display("Sam", 23);
    }
    
    static void display(String name, int age) {
        System.out.println(name);
        System.out.println(age);
    }
}
```

Метод `display` принимает два параметра. Первый параметр представляет тип `String`, а второй - тип `int`. Поэтому при вызове метода вначале в него надо передать строку, а затем число.

#### Параметры переменной длины

Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор чисел и вычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:

``` java
public class Program {
    public static void main(String args[]) {
        sum(1, 2, 3);           // 6
        sum(1, 2, 3, 4, 5);     // 15
        sum();                  // 0
    }
    
    static void sum(int ...nums) {
        int result =0;
        for (int n : nums)
            result += n;
        System.out.println(result);
    }
}
```

Троеточие перед названием параметра `int ...nums` указывает на то, что он будет необязательным и будет представлять массив. Мы можем передать в метод `sum` одно число, несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:

``` java
public static void main(String[] args) {
    sum("Welcome!", 20, 10);
    sum("Hello World!");
}

static void sum(String message, int ...nums) {
    System.out.println(message);
    int result = 0;
    for (int x : nums)
        result += x;
    System.out.println(result);
}
```

### Оператор return

Методы могут возвращать некоторое значение. Для этого применяется оператор `return`.

``` java
return возвращаемое_значение;
```

После оператора `return` указывается возвращаемое значение, которое является результатом метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.

Например:

``` java
public class Program {
    public static void main(String args[]) {
        int x = sum(1, 2, 3);
        int y = sum(1, 4, 9);
        System.out.println(x);  // 6
        System.out.println(y);  // 14
    }
    
    static int sum(int a, int b, int c) {
        return a + b + c;
    }
}
```

В методе в качестве типа возвращаемого значения вместо `void` используется любой другой тип. В данном случае метод `sum` возвращает значение типа `int`, поэтому этот тип указывается перед названием метода. Причем если в качестве возвращаемого типа для метода определен любой другой, отличный от `void`, то метод обязательно должен использовать оператор `return` для возвращения значения.

При этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции. И если функция возвращает значение типа `int`, то после оператора `return` стоит целочисленное значение, которое является объектом типа `int`. Как в данном случае это сумма значений параметров метода.

Метод может использовать несколько вызовов оператора `return` для возвращения разных значений в зависимости от некоторых условий:

``` java
public class Program {
    public static void main(String args[]) {
        System.out.println(daytime(7));     // Good morning
        System.out.println(daytime(13));    // Good after noon
        System.out.println(daytime(18));    // Good evening
        System.out.println(daytime(2));     // Good night
    }
    
    static String daytime(int hour) {     
        if (hour >24 || hour < 0)
            return "Invalid data";
        else if (hour > 21 || hour < 6)
            return "Good night";
        else if (hour >= 15)
            return "Good evening";
        else if (hour >= 11)
            return "Good after noon";
        else
            return "Good morning";
    }
}
```

Здесь метод `daytime` возвращает значение типа `String`, то есть строку, и в зависимости от значения параметра `hour` возвращаемая строка будет различаться.

#### Выход из метода

Оператор `return` применяется не только для возвращения значения из метода, но и для выхода из метода. В подобном качестве оператор `return` применяется в методах, которые ничего не возвращают, то есть имеют тип возвращаемого значения `void`:

``` java
public class Program {
    public static void main(String args[]) {
        daytime(7);     // Good morning
        daytime(13);    // Good after noon
        daytime(32);    // 
        daytime(56);    // 
        daytime(2);     // Good night
    }
    
    static void daytime(int hour) {
        if (hour >24 || hour < 0)
            return;
        if (hour > 21 || hour < 6)
            System.out.println("Good night");
        else if (hour >= 15)
            System.out.println("Good evening");
        else if (hour >= 11)
            System.out.println("Good after noon");
        else
            System.out.println("Good morning");
    }
}
```

Если переданное в метод `datetime` значение больше 24 или меньше 0, то просто выходим из метода. Возвращаемое значение после `return` указывать в этом случае не нужно.

### Перегрузка методов

В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).

Например:

``` java
public class Program {
    public static void main(String[] args) {
        System.out.println(sum(2, 3));          // 5
        System.out.println(sum(4.5, 3.2));      // 7.7
        System.out.println(sum(4, 3, 7));       // 14
    }
    
    static int sum(int x, int y) {         
        return x + y;
    }
    
    static double sum(double x, double y) {             
        return x + y;
    }
    
    static int sum(int x, int y, int z) {
        return x + y + z;
    }
}
```

Здесь определено три варианта или три перегрузки метода `sum`, но при его вызове в зависимости от типа и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит.

Стоит отметить, что на перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. Например, в следующем случае методы различаются по типу возвращаемого значения:

``` java
public class Program {
    public static void main(String[] args) {
        System.out.println(sum(2, 3));
        System.out.println(sum(4, 3));
    }
    
    static int sum(int x, int y) {
        return x + y;
    }
    
    static double sum(int x, int y) {
        return x + y;
    }
}
```

Однако перегрузкой это не будет считаться. Более того такая программа некорректна и попросту не скомпилируется, так как метод с одним и тем же количеством и типом параметров определен несколько раз.
